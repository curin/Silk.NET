<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
// ============================================= THIS FILE IS AUTOGENERATED ============================================
// =================== Please make any edits in eng/generation/Silk.Maths.Generation/VectorStatics.tt! ====================
// ============================================= THIS FILE IS AUTOGENERATED ============================================

using System;
using System.Collections;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Runtime.Serialization;
using System.Text;

namespace Silk.NET.Maths
{
    public static class <#= GetName(Dimension, FloatType) #>
    {
        #region Operators
        /// <summary>
        /// Calculate the dot product of two vectors
        /// </summary>
        /// <param name="lh">the first source vector</param>
        /// <param name="rh">the second source vector</param>
        /// <returns>the dot product</returns>
        public static T Dot<T>(<#= GetName(Dimension, FloatType) #><T> lh, <#= GetName(Dimension, FloatType) #><T> rh) <#=WhereClause("T", FloatType)#>
        {<#if (IsPowerOfTwo(Dimension)){#>
            
            switch (Unsafe.SizeOf<T>())
            {<#
                    for (int size = 1; size <= 32; size <<= 1)
                    {
                        int vectorSize = int.Max(64, (size << 3) * Dimension);
                        if (vectorSize > 512) continue; #>

                case <#=size#>:
                    if (Vector<#=vectorSize#><T>.IsSupported && Vector<#=vectorSize#>.IsHardwareAccelerated)
                    {
                        Vector<#=vectorSize#><T> result = lh.ToVector<#=vectorSize#>() * lh.ToVector<#=vectorSize#>();
                        return <#
                            for (int i = 0; i < Dimension; i++)
                            {#>result[<#= i #>]<#= i < Dimension - 1 ? " + " : ";" #><#}#>

                    }
                break;
                <#}#>

            }
            <#}#>return <#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh.<#=GetComponentName(i)#> * rh.<#=GetComponentName(i)#><#= i < Dimension - 1 ? " + " : ";" #><#}#>

        }

        <#
            if (Dimension == 3)
            {#>/// <summary>
        /// Calculate the cross product of two vectors
        /// </summary>
        /// <param name="lh">the first source vector</param>
        /// <param name="rh">the second source vector</param>
        /// <returns>the dot product</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Cross<T>(<#= GetName(Dimension, FloatType) #><T> lh, <#= GetName(Dimension, FloatType) #><T> rh) <#=WhereClause("T", FloatType)#>
        {
            return new((lh.Y * rh.Z) - (lh.Z * rh.Y), (lh.Z * rh.X) - (lh.X * rh.Z), (lh.X * rh.Y) - (lh.Y * rh.X));
        }
        <#}#>/// <summary>
        /// Returns a vector whose components are the maximum of each of the pairs of components in the two source vectors
        /// </summary>
        /// <param name="lh">the first source vector</param>
        /// <param name="rh">the second source vector</param>
        /// <returns>the max vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Max<T>(<#= GetName(Dimension, FloatType) #><T> lh, <#= GetName(Dimension, FloatType) #><T> rh) <#=WhereClause("T", FloatType)#>
        {
            return new(<#for (int i = 0; i < Dimension; i++)
            {#>T.Max(lh.<#=GetComponentName(i)#>, rh.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : ""#><#}#>);
        }
        /// <summary>
        /// Returns a vector whose components are the maximum of a component of the source vector and a scalar
        /// </summary>
        /// <param name="lh">the source vector</param>
        /// <param name="rh">the source scalar</param>
        /// <returns>the max vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Max<T>(<#= GetName(Dimension, FloatType) #><T> lh, T rh) <#=WhereClause("T", FloatType)#>
        {
            return new(<#for (int i = 0; i < Dimension; i++)
            {#>T.Max(lh.<#=GetComponentName(i)#>, rh)<#= i < Dimension - 1 ? ", " : ""#><#}#>);
        }
        /// <summary>
        /// Returns a vector whose components are the minimum of each of the pairs of components in the two source vectors
        /// </summary>
        /// <param name="lh">the first source vector</param>
        /// <param name="rh">the second source vector</param>
        /// <returns>the min vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Min<T>(<#= GetName(Dimension, FloatType) #><T> lh, <#= GetName(Dimension, FloatType) #><T> rh) <#=WhereClause("T", FloatType)#>
        {
            return new(<#for (int i = 0; i < Dimension; i++)
            {#>T.Min(lh.<#=GetComponentName(i)#>, rh.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : ""#><#}#>);
        }
        /// <summary>
        /// Returns a vector whose components are the minimum of a component of the source vector and a scalar
        /// </summary>
        /// <param name="lh">the source vector</param>
        /// <param name="rh">the source scalar</param>
        /// <returns>the min vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Min<T>(<#= GetName(Dimension, FloatType) #><T> lh, T rh) <#=WhereClause("T", FloatType)#>
        {
            return new(<#for (int i = 0; i < Dimension; i++)
            {#>T.Min(lh.<#=GetComponentName(i)#>, rh)<#= i < Dimension - 1 ? ", " : ""#><#}#>);
        }
        /// <summary>
        /// Restricts a vector between a minimum and a maximum value.
        /// </summary>
        /// <param name="val">the source vector</param>
        /// <param name="min">the min vector</param>
        /// <param name="max">the max vector</param>
        /// <returns></returns>
        public static <#= GetName(Dimension, FloatType) #><T> Clamp<T>(<#= GetName(Dimension, FloatType) #><T> val, <#= GetName(Dimension, FloatType) #><T> min, <#= GetName(Dimension, FloatType) #><T> max) <#=WhereClause("T", FloatType)#>
        {
            return new(<#for (int i = 0; i < Dimension; i++)
            {#>T.Clamp(val.<#=GetComponentName(i)#>, min.<#=GetComponentName(i)#>, max.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : ""#><#}#>);
        }
        /// <summary>
        /// Restricts a vector between a minimum and a maximum value.
        /// </summary>
        /// <param name="val">the source vector</param>
        /// <param name="min">the min vector</param>
        /// <param name="max">the max scalar</param>
        /// <returns></returns>
        public static <#= GetName(Dimension, FloatType) #><T> Clamp<T>(<#= GetName(Dimension, FloatType) #><T> val, <#= GetName(Dimension, FloatType) #><T> min, T max) <#=WhereClause("T", FloatType)#>
        {
            return new(<#for (int i = 0; i < Dimension; i++)
            {#>T.Clamp(val.<#=GetComponentName(i)#>, min.<#=GetComponentName(i)#>, max)<#= i < Dimension - 1 ? ", " : ""#><#}#>);
        }
        /// <summary>
        /// Restricts a vector between a minimum and a maximum value.
        /// </summary>
        /// <param name="val">the source vector</param>
        /// <param name="min">the min scalar</param>
        /// <param name="max">the max vector</param>
        /// <returns></returns>
        public static <#= GetName(Dimension, FloatType) #><T> Clamp<T>(<#= GetName(Dimension, FloatType) #><T> val, T min, <#= GetName(Dimension, FloatType) #><T> max) <#=WhereClause("T", FloatType)#>
        {
            return new(<#for (int i = 0; i < Dimension; i++)
            {#>T.Clamp(val.<#=GetComponentName(i)#>, min, max.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : ""#><#}#>);
        }
        /// <summary>
        /// Restricts a vector between a minimum and a maximum value.
        /// </summary>
        /// <param name="val">the source vector</param>
        /// <param name="min">the min scalar</param>
        /// <param name="max">the max scalar</param>
        /// <returns></returns>
        public static <#= GetName(Dimension, FloatType) #><T> Clamp<T>(<#= GetName(Dimension, FloatType) #><T> val, T min, T max) <#=WhereClause("T", FloatType)#>
        {
            return new(<#for (int i = 0; i < Dimension; i++)
            {#>T.Clamp(val.<#=GetComponentName(i)#>, min, max)<#= i < Dimension - 1 ? ", " : ""#><#}#>);
        }
        /// <summary>
        /// Returns a vector whose components are the absolute values of each of the specified vector's components.
        /// </summary>
        /// <param name="val">the source vector</param>
        /// <returns>the absolute value vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Abs<T>(<#= GetName(Dimension, FloatType) #><T> val) <#=WhereClause("T", FloatType)#>
        {
            return new(<#for (int i = 0; i < Dimension; i++)
            {#>T.Abs(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : ""#><#}#>);
        }
        /// <summary>
        /// Returns a vector whose components have the value of the specified vector's components but with the sign of the sign vector's components.
        /// </summary>
        /// <param name="val">the source vector</param>
        /// <param name="sign">the sign vector</param>
        /// <returns>the modified vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> CopySign<T>(<#= GetName(Dimension, FloatType) #><T> val, <#= GetName(Dimension, FloatType) #><T> sign) <#=WhereClause("T", FloatType)#>
        {
            return new(<#for (int i = 0; i < Dimension; i++)
            {#>T.CopySign(val.<#=GetComponentName(i)#>, sign.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : ""#><#}#>);
        }
        /// <summary>
        /// Returns a vector whose components have the value of the specified vector's components but with the sign of the sign scalar.
        /// </summary>
        /// <param name="val">the source vector</param>
        /// <param name="sign">the sign scalar</param>
        /// <returns>the modified vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> CopySign<T>(<#= GetName(Dimension, FloatType) #><T> val, T sign) <#=WhereClause("T", FloatType)#>
        {
            return new(<#for (int i = 0; i < Dimension; i++)
            {#>T.CopySign(val.<#=GetComponentName(i)#>, sign)<#= i < Dimension - 1 ? ", " : ""#><#}#>);
        }
        /// <summary>
        /// Returns a vector whose components have the value of the specified scalar but with the sign of the sign vector's components.
        /// </summary>
        /// <param name="val">the source scalar</param>
        /// <param name="sign">the sign vector</param>
        /// <returns>the modified vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> CopySign<T>(T val, <#= GetName(Dimension, FloatType) #><T> sign) <#=WhereClause("T", FloatType)#>
        {
            return new(<#for (int i = 0; i < Dimension; i++)
            {#>T.CopySign(val, sign.<#=GetComponentName(i)#>)<#=i < Dimension - 1 ? ", " : ""#><#
                }#>);
        }
        /// <summary>
        /// Returns a vector whose components have the value of the sign of the specified vector's components.
        /// </summary>
        /// <param name="val">the source vector</param>
        /// <returns>the sign vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Sign<T>(<#= GetName(Dimension, FloatType) #><T> val) <#=WhereClause("T", FloatType)#>
        {
            return new(<#for (int i = 0; i < Dimension; i++)
            {#>T.CreateTruncating(T.Sign(val.<#=GetComponentName(i)#>))<#= i < Dimension - 1 ? ", " : ""#><#}#>);
        }

        /// <summary>
        /// Returns the reflected incident vector across the given normal vector
        /// </summary>
        /// <param name="incident">the incident vector</param>
        /// <param name="normal">the normal vector</param>
        /// <returns>the reflected vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Reflect<T>(<#= GetName(Dimension, FloatType) #><T> incident, <#= GetName(Dimension, FloatType) #><T> normal) <#=WhereClause("T", FloatType)#>
        {
            <#= GetName(Dimension, FloatType) #><T> temp = normal * Dot(incident, normal);
            return incident - (temp + temp);
        }

        /// <summary>
        /// Returns a vector whose components have been linearly interpolated between the two source vectors based on the time vector
        /// </summary>
        /// <param name="vector0">the first source vector</param>
        /// <param name="vector1">the second source vector</param>
        /// <param name="t">the time vector</param>
        /// <returns>the interpolated vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Lerp<T>(<#= GetName(Dimension, FloatType) #><T> vector0, <#= GetName(Dimension, FloatType) #><T> vector1, <#= GetName(Dimension, FloatType) #><T> t) <#=WhereClause("T", FloatType)#>
        {
            return vector0 * <#= GetName(Dimension, FloatType) #>.Max(<#= GetName(Dimension, FloatType) #><T>.One - t, <#= GetName(Dimension, FloatType) #><T>.Zero) + vector1 * <#= GetName(Dimension, FloatType) #>.Max(t, <#= GetName(Dimension, FloatType) #><T>.Zero);
        }
        /// <summary>
        /// Returns a vector whose components have been linearly interpolated between the two source vectors based on the time vector which is clamped between 0 and 1
        /// </summary>
        /// <param name="vector0">the first vector</param>
        /// <param name="vector1">the second vector</param>
        /// <param name="t">the time vector</param>
        /// <returns>the interpolated vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> ClampedLerp<T>(<#= GetName(Dimension, FloatType) #><T> vector0, <#= GetName(Dimension, FloatType) #><T> vector1, <#= GetName(Dimension, FloatType) #><T> t) <#=WhereClause("T", FloatType)#>
        {
            t = <#= GetName(Dimension, FloatType) #>.Clamp(t, <#= GetName(Dimension, FloatType) #><T>.Zero, <#= GetName(Dimension, FloatType) #><T>.One);
            return vector0 * (T.One - t) + vector1 * t;
        }

        /// <summary>
        /// Returns a vector whose components have been linearly interpolated between the two source vectors based on the time scalar
        /// </summary>
        /// <param name="vector0">the first vector</param>
        /// <param name="vector1">the second vector</param>
        /// <param name="t">the time scalar</param>
        /// <returns>the interpolated vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Lerp<T>(<#= GetName(Dimension, FloatType) #><T> vector0, <#= GetName(Dimension, FloatType) #><T> vector1, T t) <#=WhereClause("T", FloatType)#>
        {
            return vector0 * T.Max(T.One - t, T.Zero) * vector1 * T.Max(t, T.Zero);
        }
        /// <summary>
        /// Returns a vector whose components have been linearly interpolated between the two source vectors based on the time scalar which is clamped between 0 and 1
        /// </summary>
        /// <param name="vector0">the first vector</param>
        /// <param name="vector1">the second vector</param>
        /// <param name="t">the time scalar</param>
        /// <returns>the interpolated vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> ClampedLerp<T>(<#= GetName(Dimension, FloatType) #><T> vector0, <#= GetName(Dimension, FloatType) #><T> vector1, T t) <#=WhereClause("T", FloatType)#>
        {
            t = T.Clamp(t, T.Zero, T.One);
            return vector0 * (T.One - t) * vector1 * t;
        }<#
            for (int i = MinMatRow; i <= MaxMatRow; i++)
            {
                for (int j = MinMatCol; j <= MaxMatCol; j++)
                {#>
                
        /// <summary>
        /// Transforms this vector by multiplying it in homogenous space with a given matrix
        /// </summary>
        /// <param name="value">the source vector</param>
        /// <param name="transform">the transform matrix</param>
        public static <#= GetName(Dimension, FloatType) #><T> Transform<T>(<#= GetName(Dimension, FloatType) #><T> value, Matrix<#=i#>x<#=j#><#=FloatType ? "F" : "I"#><T> transform) <#=WhereClause("T", FloatType)#> => <#=GetMatrixMultiplication(i, j, Dimension, FloatType, "value", "transform", true)#>
        /// <summary>
        /// Transforms this vector by multiplying it with a given matrix
        /// </summary>
        /// <param name="value">the source vector</param>
        /// <param name="transform">the transform matrix</param>
        public static <#= GetName(Dimension, FloatType) #><T> TransformNormal<T>(<#= GetName(Dimension, FloatType) #><T> value, Matrix<#=i#>x<#=j#><#=FloatType ? "F" : "I"#><T> transform) <#=WhereClause("T", FloatType)#> => <#=GetMatrixMultiplication(i, j, Dimension, FloatType, "value", "transform", false)#>
        <#}
            }#>/// <summary>
        /// Transforms this vector by multiplying it in homogenous space with a given matrix
        /// </summary>
        /// <param name="value">the source vector</param>
        /// <param name="transform">the transform matrix</param>
        public static <#= GetName(Dimension, FloatType) #><T> Transform<T>(<#= GetName(Dimension, FloatType) #><T> value, Matrix5x4<#=FloatType ? "F" : "I"#><T> transform) <#=WhereClause("T", FloatType)#> => <#=GetMatrixMultiplication(5, 4, Dimension, FloatType, "value", "transform", true)#>
        /// <summary>
        /// Transforms this vector by multiplying it with a given matrix
        /// </summary>
        /// <param name="value">the source vector</param>
        /// <param name="transform">the transform matrix</param>
        public static <#= GetName(Dimension, FloatType) #><T> TransformNormal<T>(<#= GetName(Dimension, FloatType) #><T> value, Matrix5x4<#=FloatType ? "F" : "I"#><T> transform) <#=WhereClause("T", FloatType)#> => <#=GetMatrixMultiplication(5, 4, Dimension, FloatType, "value", "transform", false)#>
            #endregion

<#
    if (FloatType)
    {#>
        #region Floating Point Specific
        /// <summary>
        /// Returns the normalized version of the given vector
        /// </summary>
        /// <param name="vector">the source vector</param>
        /// <returns>the normalized vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Normalize<T>(<#= GetName(Dimension, FloatType) #><T> vector) <#=WhereClause("T", FloatType)#>
        {
            return vector / vector.Length;
        }

        /// <summary>
        /// Returns a vector whose components are the value of the Sqrt of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Sqrt vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Sqrt<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Sqrt(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Acosh of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Acosh vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Acosh<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Acosh(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Asinh of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Asinh vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Asinh<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Asinh(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Atanh of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Atanh vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Atanh<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Atanh(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Cosh of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Cosh vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Cosh<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Cosh(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Sinh of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Sinh vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Sinh<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Sinh(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Tanh of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Tanh vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Tanh<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Tanh(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Acos of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Acos vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Acos<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Acos(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the AcosPi of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the AcosPi vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> AcosPi<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.AcosPi(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Asin of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Asin vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Asin<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Asin(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the AsinPi of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the AsinPi vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> AsinPi<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.AsinPi(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Atan of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Atan vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Atan<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Atan(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the AtanPi of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the AtanPi vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> AtanPi<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.AtanPi(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Cos of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Cos vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Cos<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Cos(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the CosPi of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the CosPi vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> CosPi<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.CosPi(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Sin of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Sin vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Sin<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Sin(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the SinPi of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the SinPi vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> SinPi<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.SinPi(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Tan of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Tan vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Tan<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Tan(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the TanPi of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the TanPi vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> TanPi<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.TanPi(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the DegreesToRadians of the source vector's components
        /// </summary>
        /// <param name="degrees">the source vector</param>
        /// <returns>the DegreesToRadians vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> DegreesToRadians<T>(<#= GetName(Dimension, FloatType) #><T> degrees) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.DegreesToRadians(degrees.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the RadiansToDegrees of the source vector's components
        /// </summary>
        /// <param name="radians">the source vector</param>
        /// <returns>the RadiansToDegrees vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> RadiansToDegrees<T>(<#= GetName(Dimension, FloatType) #><T> radians) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.RadiansToDegrees(radians.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns two vectors whose components are the value of the SinCos of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the SinCos vector</returns>
        public static (<#= GetName(Dimension, FloatType) #><T>, <#= GetName(Dimension, FloatType) #><T>) SinCos<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#>
        {<#
                for (int i = 0; i < Dimension; i++)
                {#>

            (T, T) sinCos<#=GetComponentName(i)#> = T.SinCos(x.<#=GetComponentName(i)#>);<#}#>

            return (new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>sinCos<#=GetComponentName(i)#>.Item1<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>), new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>sinCos<#=GetComponentName(i)#>.Item2<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>));
        }
        /// <summary>
        /// Returns two vectors whose components are the value of the SinCosPi of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the SinCosPi vector</returns>
        public static (<#= GetName(Dimension, FloatType) #><T>, <#= GetName(Dimension, FloatType) #><T>) SinCosPi<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#>
        {<#
                for (int i = 0; i < Dimension; i++)
                {#>

            (T, T) sinCos<#=GetComponentName(i)#> = T.SinCosPi(x.<#=GetComponentName(i)#>);<#}#>

            return (new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>sinCos<#=GetComponentName(i)#>.Item1<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>), new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>sinCos<#=GetComponentName(i)#>.Item2<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>));
        }
        /// <summary>
        /// Returns a vector whose components are the value of the Log of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Log vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Log<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Log(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Log of the source vector's components using the newBase vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <param name="newBase">the newBase vector</param>
        /// <returns>the Log vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Log<T>(<#= GetName(Dimension, FloatType) #><T> x, <#= GetName(Dimension, FloatType) #><T> newBase) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Log(x.<#=GetComponentName(i)#>, newBase.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Log of the source vector's components using the newBase scalar
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <param name="newBase">the newBase scalar</param>
        /// <returns>the Log vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Log<T>(<#= GetName(Dimension, FloatType) #><T> x, T newBase) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Log(x.<#=GetComponentName(i)#>, newBase)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the LogP1 of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the LogP1 vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> LogP1<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.LogP1(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Log2 of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Log2 vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Log2<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Log2(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Log2P1 of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Log2P1 vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Log2P1<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Log2P1(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Log10 of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Log10 vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Log10<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Log10(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Log10P1 of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Log10P1 vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Log10P1<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Log10P1(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Exp of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Exp vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Exp<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Exp(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the ExpM1 of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the ExpM1 vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> ExpM1<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.ExpM1(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Exp2 of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Exp2 vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Exp2<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Exp2(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Exp2M1 of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Exp2M1 vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Exp2M1<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Exp2M1(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Exp10 of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Exp10 vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Exp10<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Exp10(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Exp10M1 of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Exp10M1 vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Exp10M1<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Exp10M1(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Pow of the first source vector's components to the power of the second source vector's components
        /// </summary>
        /// <param name="x">the first source vector</param>
        /// <param name="y">the second source vector</param>
        /// <returns>the Log vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Pow<T>(<#= GetName(Dimension, FloatType) #><T> x, <#= GetName(Dimension, FloatType) #><T> y) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Pow(x.<#=GetComponentName(i)#>, y.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Pow of the first source vector's components to the power of the source scalar
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <param name="y">the source scalar</param>
        /// <returns>the Log vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Pow<T>(<#= GetName(Dimension, FloatType) #><T> x, T y) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Pow(x.<#=GetComponentName(i)#>, y)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Cbrt of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Cbrt vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Cbrt<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Cbrt(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Hypotenuse of the right triangles created from the two vector's components
        /// </summary>
        /// <param name="x">the first source vector</param>
        /// <param name="y">the second source vector</param>
        /// <returns>the Hypot vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Hypot<T>(<#= GetName(Dimension, FloatType) #><T> x, <#= GetName(Dimension, FloatType) #><T> y) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Hypot(x.<#=GetComponentName(i)#>, y.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Hypotenuse of the right triangles created from the vector's component and the scalar value
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <param name="y">the source scalar</param>
        /// <returns>the Hypot vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Hypot<T>(<#= GetName(Dimension, FloatType) #><T> x, T y) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Hypot(x.<#=GetComponentName(i)#>, y)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the RootN of the source vector's components using the given root
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <param name="n">the root</param>
        /// <returns>the RootN vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> RootN<T>(<#= GetName(Dimension, FloatType) #><T> x, int n) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.RootN(x.<#=GetComponentName(i)#>, n)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Round of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Round vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Round<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Round(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Round of the source vector's components to the given digits
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <param name="digits">digits to round to</param>
        /// <returns>the Round vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Round<T>(<#= GetName(Dimension, FloatType) #><T> x, int digits) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Round(x.<#=GetComponentName(i)#>, digits)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Round of the source vector's components using the given mode
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <param name="mode">the rounding mode</param>
        /// <returns>the Round vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Round<T>(<#= GetName(Dimension, FloatType) #><T> x, MidpointRounding mode) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Round(x.<#=GetComponentName(i)#>, mode)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Round of the source vector's components to the given digits using the given mode
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <param name="digits">digits to round to</param>
        /// <param name="mode">the rounding mode</param>
        /// <returns>the Round vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Round<T>(<#= GetName(Dimension, FloatType) #><T> x, int digits, MidpointRounding mode) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Round(x.<#=GetComponentName(i)#>, digits, mode)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Floor of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Floor vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Floor<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Floor(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Ceiling of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Ceiling vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Ceiling<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Ceiling(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Truncate of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Truncate vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Truncate<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Truncate(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Atan2 of the source vector's components using the second source vector's components
        /// </summary>
        /// <param name="x">the first source vector</param>
        /// <param name="y">the second source vector</param>
        /// <returns>the Atan2 vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Atan2<T>(<#= GetName(Dimension, FloatType) #><T> x, <#= GetName(Dimension, FloatType) #><T> y) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Atan2(x.<#=GetComponentName(i)#>, y.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Atan2 of the source vector's components using the source scalar
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <param name="y">the source scalar</param>
        /// <returns>the Atan2 vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Atan2<T>(<#= GetName(Dimension, FloatType) #><T> x, T y) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Atan2(x.<#=GetComponentName(i)#>, y)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Atan2Pi of the source vector's components using the second source vector's components
        /// </summary>
        /// <param name="x">the first source vector</param>
        /// <param name="y">the second source vector</param>
        /// <returns>the Atan2Pi vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Atan2Pi<T>(<#= GetName(Dimension, FloatType) #><T> x, <#= GetName(Dimension, FloatType) #><T> y) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Atan2Pi(x.<#=GetComponentName(i)#>, y.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Atan2Pi of the source vector's components using the source scalar
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <param name="y">the source scalar</param>
        /// <returns>the Atan2Pi vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> Atan2Pi<T>(<#= GetName(Dimension, FloatType) #><T> x, T y) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Atan2Pi(x.<#=GetComponentName(i)#>, y)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the BitDecrement of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the BitDecrement vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> BitDecrement<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.BitDecrement(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the BitIncrement of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the BitIncrement vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> BitIncrement<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.BitIncrement(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the FusedMultiplyAdd between the source vectors
        /// </summary>
        /// <param name="left">the first source vector</param>
        /// <param name="right">the second source vector</param>
        /// <param name="addend">the addend source vector</param>
        /// <returns>the FusedMultiplyAdd vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> FusedMultiplyAdd<T>(<#= GetName(Dimension, FloatType) #><T> left, <#= GetName(Dimension, FloatType) #><T> right, <#= GetName(Dimension, FloatType) #><T> addend) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.FusedMultiplyAdd(left.<#=GetComponentName(i)#>, right.<#=GetComponentName(i)#>, addend.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the FusedMultiplyAdd between the source vectors and the source scalar
        /// </summary>
        /// <param name="left">the first source vector</param>
        /// <param name="right">the second source vector</param>
        /// <param name="addend">the addend source scalar</param>
        /// <returns>the FusedMultiplyAdd vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> FusedMultiplyAdd<T>(<#= GetName(Dimension, FloatType) #><T> left, <#= GetName(Dimension, FloatType) #><T> right, T addend) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.FusedMultiplyAdd(left.<#=GetComponentName(i)#>, right.<#=GetComponentName(i)#>, addend)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the FusedMultiplyAdd between the source vectors and the source scalar
        /// </summary>
        /// <param name="left">the first source vector</param>
        /// <param name="right">the second source scalar</param>
        /// <param name="addend">the addend source vector</param>
        /// <returns>the FusedMultiplyAdd vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> FusedMultiplyAdd<T>(<#= GetName(Dimension, FloatType) #><T> left, T right, <#= GetName(Dimension, FloatType) #><T> addend) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.FusedMultiplyAdd(left.<#=GetComponentName(i)#>, right, addend.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the FusedMultiplyAdd between the source vectors and the source scalar
        /// </summary>
        /// <param name="left">the first source vector</param>
        /// <param name="right">the second source scalar</param>
        /// <param name="addend">the addend source scalar</param>
        /// <returns>the FusedMultiplyAdd vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> FusedMultiplyAdd<T>(<#= GetName(Dimension, FloatType) #><T> left, T right, T addend) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.FusedMultiplyAdd(left.<#=GetComponentName(i)#>, right, addend)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the ReciprocalEstimate of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the ReciprocalEstimate vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> ReciprocalEstimate<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.ReciprocalEstimate(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the ReciprocalSqrtEstimate of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the ReciprocalSqrtEstimate vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> ReciprocalSqrtEstimate<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.ReciprocalSqrtEstimate(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the ILogB of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the ILogB vector</returns>
        public static <#= GetName(Dimension, false) #><int> ILogB<T>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.ILogB(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the ScaleB of the source vector's components using the second source vector's components
        /// </summary>
        /// <param name="x">the first source vector</param>
        /// <param name="n">the second source vector</param>
        /// <returns>the ScaleB vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> ScaleB<T>(<#= GetName(Dimension, FloatType) #><T> x, <#= GetName(Dimension, false) #><int> n) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.ScaleB(x.<#=GetComponentName(i)#>, n.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the ScaleB of the source vector's components using the second source scalar
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <param name="n">the source scalar</param>
        /// <returns>the ScaleB vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> ScaleB<T>(<#= GetName(Dimension, FloatType) #><T> x, int n) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.ScaleB(x.<#=GetComponentName(i)#>, n)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Round of the source vector's components truncated to an int
        /// </summary>
        /// <typeparam name="TOther">the integer type</typeparam>
        /// <param name="x">the source vector</param>
        /// <returns>the Round vector</returns>
        public static <#= GetName(Dimension, false) #><TOther> RoundToInt<T, TOther>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> where TOther : unmanaged, IBinaryInteger<TOther> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>TOther.CreateTruncating(T.Round(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Floor of the source vector's components truncated to an int
        /// </summary>
        /// <typeparam name="TOther">the integer type</typeparam>
        /// <param name="x">the source vector</param>
        /// <returns>the Floor vector</returns>
        public static <#= GetName(Dimension, false) #><TOther> FloorToInt<T, TOther>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> where TOther : unmanaged, IBinaryInteger<TOther> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>TOther.CreateTruncating(T.Floor(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns a vector whose components are the value of the Ceiling of the source vector's components truncated to an int
        /// </summary>
        /// <typeparam name="TOther">the integer type</typeparam>
        /// <param name="x">the source vector</param>
        /// <returns>the Ceiling vector</returns>
        public static <#= GetName(Dimension, false) #><TOther> CeilingToInt<T, TOther>(<#= GetName(Dimension, FloatType) #><T> x) <#=WhereClause("T", FloatType)#> where TOther : unmanaged, IBinaryInteger<TOther> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>TOther.CreateTruncating(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        #endregion
<#
    }
    else
    {#>
        #region Integer Specific
        /// <summary>
        /// Returns a vector whose components are the Log2 value of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the Log2 vector</returns>
        public static <#= GetName(Dimension, false) #><T> Log2<T>(<#= GetName(Dimension, false) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.Log2(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Returns two vectors whose components are the DivRem value of the two source vectors
        /// </summary>
        /// <param name="left">the quotient source vector</param>
        /// <param name="right">the dividend source vector</param>
        /// <returns>the DivRem vectors</returns>
        public static (<#= GetName(Dimension, false) #><T>, <#= GetName(Dimension, false) #><T>) DivRem<T>(<#= GetName(Dimension, false) #><T> left, <#= GetName(Dimension, false) #><T> right) <#=WhereClause("T", FloatType)#>
        {<#
                for (int i = 0; i < Dimension; i++)
                {#>

            (T, T) divRem<#=GetComponentName(i)#> = T.DivRem(left.<#=GetComponentName(i)#>, right.<#=GetComponentName(i)#>);<#}#>

            return (new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>divRem<#=GetComponentName(i)#>.Item1<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>), new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>divRem<#=GetComponentName(i)#>.Item2<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>));
        }

        /// <summary>
        /// Returns two vectors whose components are the DivRem value of the source vector and the source scalar
        /// </summary>
        /// <param name="left">the quotient source vector</param>
        /// <param name="right">the dividend source scalar</param>
        /// <returns>the DivRem vectors</returns>
        public static (<#= GetName(Dimension, false) #><T>, <#= GetName(Dimension, false) #><T>) DivRem<T>(<#= GetName(Dimension, false) #><T> left, T right) <#=WhereClause("T", FloatType)#>
        {<#
                for (int i = 0; i < Dimension; i++)
                {#>

            (T, T) divRem<#=GetComponentName(i)#> = T.DivRem(left.<#=GetComponentName(i)#>, right);<#}#>

            return (new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>divRem<#=GetComponentName(i)#>.Item1<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>), new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>divRem<#=GetComponentName(i)#>.Item2<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>));
        }

        /// <summary>
        /// Returns a vector whose components are the PopCount of the source vector's components
        /// </summary>
        /// <param name="x">the source vector</param>
        /// <returns>the PopCount vector</returns>
        public static <#= GetName(Dimension, false) #><T> PopCount<T>(<#= GetName(Dimension, false) #><T> x) <#=WhereClause("T", FloatType)#> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.PopCount(x.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        #endregion
<#
    }#>
    }
}
<#+
        public string GetName(int dimension, bool floatType)
        {
            return "Vector" + dimension + (floatType ? "F" : "I");
        }

        public string WhereClause(string TypeParam, bool floatType)
        {
            return "where T : unmanaged, " + (FloatType ? "IFloatingPointIeee754" : "IBinaryInteger") + "<T>";
        }

        private string GetComponentName(int dimension, bool Caps = true)
        {
            switch (dimension)
            {
                default:
                case 0:
                    return Caps ? "X" : "x";
                case 1:
                    return Caps ? "Y" : "y";
                case 2:
                    return Caps ? "Z" : "z";
                case 3:
                    return Caps ? "W" : "w";
                case 4:
                    return Caps ? "V" : "v";
                case 5:
                    return Caps ? "U" : "u";
            }
        }

        public string GetSwizzleName(int[] components, string separator)
        {
            string st = "";
            for (int i = 0; i < components.Length; i++)
            {
                st += GetComponentName(components[i]) + ((i < components.Length - 1) ? separator : "");
            }
            return st;
        }

        private string ForEachComponent(int dimensions, string prefix, string separator, string postfix, bool Caps = true, int start = 0)
        {
            string st = prefix;
            for (int i = start; i < dimensions; i++)
            {
                st += GetComponentName(i, Caps);

                if (i < dimensions - 1)
                {
                    st += separator;
                }
            }
            st += postfix;
        
        return st;
        }

        private string ForEachComponent(int dimensions, string prefix, string val, string separator, string postfix, int start = 0)
        {
            string st = prefix;
            for (int i = 0; i < dimensions; i++)
            {
                st += val;

                if (i < dimensions - 1)
                {
                    st += separator;
                }
            }
            st += postfix;
        
        return st;
        }

        private bool IsPowerOfTwo(int i)
        {
            return (i != 0) && ((i & (i - 1)) == 0);
        }

        private string GetMatrixMultiplication(int matrixRows, int matrixCols, int dimension, bool floatType, string vectorName, string matrixName, bool homogenous)
        {
            string ret;
            string components;
            if (matrixRows < dimension)
            {
                components = "";
                for (int i = 0; i < matrixRows; i++)
                    components += GetComponentName(i);
                ret = "(" + vectorName + ".Swizzle." + components + " * " + matrixName + ")";
            }
            else if (matrixRows == dimension)
            {
                ret = "(" + vectorName + " * " + matrixName + ")";
            }
            else
            {
                ret = "(new Vector" + dimension + (floatType ? "F" : "I") + "<T>(";
                for (int i = 0; i < dimension; i++)
                    ret += vectorName + "." + GetComponentName(i) + (i < dimension - 1 ? ", " : ") * ");
                ret += matrixName + ")";
            }

            if (matrixCols > dimension)
            {
                components = "";
                for (int i = 0; i < dimension; i++)
                    components += GetComponentName(i);
                ret += "Swizzle." + components;
            }
            else if (matrixCols < dimension)
            {
                int diff = dimension - matrixCols;
                components = "";
                for (int i = 0; i < diff; i++)
                    components += (i < diff - 2 || !homogenous ? "T.Zero" : "T.One") + (i < diff - 1 ? ", " : ")");
                ret = "new Vector" + dimension + (floatType ? "F" : "I") + "<T>(" + ret + components;
            }

            return ret + ";";
}#>