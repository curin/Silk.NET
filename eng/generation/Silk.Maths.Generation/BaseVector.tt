<#@ template debug="true" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
// ============================================= THIS FILE IS AUTOGENERATED ============================================
// =================== Please make any edits in eng/generation/Silk.Maths.Generation/BaseVector.tt! ====================
// ============================================= THIS FILE IS AUTOGENERATED ============================================

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Runtime.Serialization;
using System.Text;

namespace Silk.NET.Maths
{
    public unsafe <#=Immutable ? "readonly" : ""#> struct <#= GetName(Dimension, FloatType) #><T> :
        IEquatable<<#= GetName(Dimension, FloatType) #><T>>,
        IFormattable,
        IParsable<<#= GetName(Dimension, FloatType) #><T>>,
        IReadOnlyList<T>,
        ISpanFormattable,
        ISpanParsable<<#= GetName(Dimension, FloatType) #><T>>,
        IUtf8SpanFormattable,
        IUtf8SpanParsable<<#= GetName(Dimension, FloatType) #><T>>
        where T : unmanaged, <#= FloatType ? "IFloatingPointIeee754" : "IBinaryInteger" #><T>
    {
        <#
            for (int i = 0; i < Dimension; i++)
            {#>private <#=Immutable ? "readonly" : ""#> T _<#= GetComponentName(i, false)#>;
        <#}#>

        <#
            for (int i = 0; i < Dimension; i++)
            {#>
        /// <summary>
        /// The <#= GetComponentName(i)#> component of the vector
        /// </summary>
        [DataMember]
        public T <#= GetComponentName(i)#>
        {
            get => _<#= GetComponentName(i, false)#>;
            <#if (!Immutable){#>set => _<#= GetComponentName(i, false)#> = value;<#}#>
        }
        <#}#>

        /// <summary>
        /// Retrieve a reference to the component at the given index
        /// </summary>
        /// <param name="index">zero-based index of the component</param>
        /// <returns>reference to the component</returns>
        public ref readonly T this[int index] => ref AsSpan()[index];

        /// <summary>
        /// The square length of the vector
        /// </summary>
        public T LengthSquared => Dot(this);

        /// <summary>
        /// The number of components in this vector
        /// </summary>
        public int Count { get; } = <#= Dimension #>;

        /// <summary>
        /// Creates a vector whose components have the specified values
        /// </summary>
        <#
            for (int i = 0; i < Dimension; i++)
            {#>/// <param name="<#=GetComponentName(i, false)#>">the value assigned to the <#=GetComponentName(i)#> component</param>
        <#}#>
public <#= GetName(Dimension, FloatType) #>(<#= ForEachComponent(Dimension, "T ", ", T ", "", false) #>)
        {
        <#
                for (int i = 0; i < Dimension; i++)
                {#>    _<#= GetComponentName(i, false) #> = <#= GetComponentName(i, false) #>;
        <#}#>}

        <#
            for (int i = MinDim; i < Dimension; i++)
            {#>/// <summary>
        /// Creates a vector whose components are from the given vector and the specified values
        /// </summary>
        /// <param name="vec">the source vector</param>
        <#
            for (int j = i; j < Dimension; j++)
            {#>/// <param name="<#=GetComponentName(j, false)#>">the value assigned to the <#=GetComponentName(j)#> component</param>
        <#
            }#>

        public <#= GetName(Dimension, FloatType) #>(<#= GetName(i, FloatType) #><T> vec, <#= ForEachComponent(Dimension, "T ", ", T ", "", false, i) #>)
        {<#
                for (int j = 0; j < i; j++)
                {#>
                
            _<#= GetComponentName(j, false) #> = vec.<#= GetComponentName(j) #>;<#}#><#
                for (int j = i; j < Dimension; j++)
                {#>

            _<#= GetComponentName(j, false) #> = <#= GetComponentName(j, false) #>;<#}#>

        }
        <#}#>
        
        /// <summary>
        /// Creates a vector whose elements have the specified value
        /// </summary>
        /// <param name="value">the value assigned to the X and Y components</param>
        public <#= GetName(Dimension, FloatType) #>(T value) : this(<#= ForEachComponent(Dimension, "", "value", ", ", "")#>)
        {
        }

        /// <summary>
        /// Creates a vector whose components from the given <see cref="ReadOnlySpan{T}"/>. The span must have at least 2 elements.
        /// </summary>
        /// <param name="values">the span of elements to assign to the X and Y components</param>
        public <#= GetName(Dimension, FloatType) #>(ReadOnlySpan<T> values)
        {
            ArgumentOutOfRangeException.ThrowIfLessThan(values.Length, Count, nameof(values));

        <#
                for (int i = 0; i < Dimension; i++)
                {#>    _<#= GetComponentName(i, false) #> = values[<#= i #>];
        <#}#>}

        /// <summary>
        /// Retrieve a span representation of this vector
        /// </summary>
        /// <returns>the span of this vector</returns>
        public <#=Immutable ? "ReadOnly" : ""#>Span<T> AsSpan() => MemoryMarshal.Create<#=Immutable ? "ReadOnly" : ""#>Span(<#=Immutable ? "in" : "ref"#> _x, Count);

        /// <summary>Copies the elements of the vector to a specified array starting at a specified index position.</summary>
        /// <param name="span">The destination span.</param>
        /// <param name="index">The index at which to copy the first element of the vector.</param>
        /// <exception cref="ArgumentException">The number of elements in the current instance is greater than in the array.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="index"> is less then zero.</paramref></exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="index"> is greater then or equal to the array length.</paramref></exception>
        /// <remarks>array must have a sufficient number of elements to accommodate the two vector elements. In other words, elements index and index + 1 must already exist in array.</remarks>
        public void CopyTo(Span<T> span, int index = 0)
        {
            if ((index < 0) || (index >= span.Length))
            {
                throw new ArgumentOutOfRangeException(nameof(index), "Specified argument was out of the range of valid values.");
            }

            if ((span.Length - index) < Count)
            {
                throw new ArgumentException("Value does not fall within the expected range.");
            }

            for (int i = 0; i< Count; i++)
            {
                span[i + index] = this[i];
            }
        }

        /// <summary>Copies the elements of the vector to a specified array starting at a specified index position.</summary>
        /// <param name="array">The destination array.</param>
        /// <param name="index">The index at which to copy the first element of the vector.</param>
        /// <exception cref="ArgumentNullException"><paramref name="array"> is <c>null</c></paramref></exception>
        /// <exception cref="ArgumentException">The number of elements in the current instance is greater than in the array.</exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="index"> is less then zero.</paramref></exception>
        /// <exception cref="ArgumentOutOfRangeException"><paramref name="index"> is greater then or equal to the array length.</paramref></exception>
        /// <remarks>array must have a sufficient number of elements to accommodate the two vector elements. In other words, elements index and index + 1 must already exist in array.</remarks>
        public void CopyTo(T[]? array, int index)
        {
            if (array is null)
            {
                throw new NullReferenceException("Object reference not set to an instance of an object.");
            }

            if ((index < 0) || (index >= array.Length))
            {
                throw new ArgumentOutOfRangeException(nameof(index), "Specified argument was out of the range of valid values.");
            }

            if ((array.Length - index) < Count)
            {
                throw new ArgumentException("Value does not fall within the expected range.");
            }

            for (int i = 0; i < Count; i++)
            {
                array[i + index] = this[i];
            }
        }

        /// <summary>
        /// Gets a vector whose components are all equal to zero
        /// </summary>
        public static <#= GetName(Dimension, FloatType) #><T> Zero => new(T.Zero);

        /// <summary>
        /// Gets a vector whose components are all equal to one
        /// </summary>
        public static <#= GetName(Dimension, FloatType) #><T> One => new(T.One);

        <#
            for (int i = 0; i < Dimension; i++)
            {#>
        /// <summary>
        /// Gets a vector whose <#= GetComponentName(i)#> component is equal to one and all others are equal to zero
        /// </summary>
        public static <#= GetName(Dimension, FloatType) #><T> Unit<#= GetComponentName(i)#> => new(<#
                for (int j = 0; j < Dimension; j++)
                {#><#= ((j == i) ? "T.One" : "T.Zero") + ((j < Dimension - 1) ? ", " : ");") #><#}
        }#>


        #region Operators
        /// <summary>
        /// Returns the dot product of this and another vector
        /// </summary>
        /// <param name="other">the other vector</param>
        /// <returns>the dot product</returns>
        public T Dot(<#= GetName(Dimension, FloatType) #><T> other) => <#= GetName(Dimension, FloatType) #>.Dot(this, other);

        <#
            if (Dimension == 3)
            {#>/// <summary>
        /// Cross Multiply this vector with another vector
        /// </summary>
        /// <param name="other">the other vector</param>
        /// <returns>the dot product</returns>
        public <#= GetName(Dimension, FloatType) #><T> Cross(<#= GetName(Dimension, FloatType) #><T> other) => <#= GetName(Dimension, FloatType) #>.Cross(this, other);
        <#}#>

        /// <summary>
        /// For each component, set the value to the max value between the component and another vector's matching component
        /// </summary>
        /// <param name="other">the other vector</param>
        public <#= GetName(Dimension, FloatType) #><T> Max(<#= GetName(Dimension, FloatType) #><T> other) => <#= GetName(Dimension, FloatType) #>.Max(this, other);
        /// <summary>
        /// For each component, set the value to the max value between the component and a scalar value
        /// </summary>
        /// <param name="other">the scalar</param>
        public <#= GetName(Dimension, FloatType) #><T> Max(T other) => <#= GetName(Dimension, FloatType) #>.Max(this, other);
        /// <summary>
        /// For each component, set the value to the min value between the component and another vector's matching component
        /// </summary>
        /// <param name="other">the other vector</param>
        public <#= GetName(Dimension, FloatType) #><T> Min(<#= GetName(Dimension, FloatType) #><T> other) => <#= GetName(Dimension, FloatType) #>.Min(this, other);
        /// <summary>
        /// For each component, set the value to the min value between the component and a scalar value
        /// </summary>
        /// <param name="other">the scalar</param>
        public <#= GetName(Dimension, FloatType) #><T> Min(T other) => <#= GetName(Dimension, FloatType) #>.Min(this, other);
        /// <summary>
        /// For each component, clamp the value between the values of the matching components from a min and max vector
        /// </summary>
        /// <param name="min">the min vector</param>
        /// <param name="max">the max vector</param>
        public <#= GetName(Dimension, FloatType) #><T> Clamp(<#= GetName(Dimension, FloatType) #><T> min, <#= GetName(Dimension, FloatType) #><T> max) => <#= GetName(Dimension, FloatType) #>.Clamp(this, min, max);
        /// <summary>
        /// For each component, clamp the value between the values of the matching components from a min vector and max scalar
        /// </summary>
        /// <param name="min">the min vector</param>
        /// <param name="max">the max vector</param>
        public <#= GetName(Dimension, FloatType) #><T> Clamp(<#= GetName(Dimension, FloatType) #><T> min, T max) => <#= GetName(Dimension, FloatType) #>.Clamp(this, min, max);
        /// <summary>
        /// For each component, clamp the value between the values of the matching components from a max vector and a min scalar
        /// </summary>
        /// <param name="min">the min vector</param>
        /// <param name="max">the max vector</param>
        public <#= GetName(Dimension, FloatType) #><T> Clamp(T min, <#= GetName(Dimension, FloatType) #><T> max) => <#= GetName(Dimension, FloatType) #>.Clamp(this, min, max);
        /// <summary>
        /// For each component, clamp the value between the values of a min and max scalar
        /// </summary>
        /// <param name="min">the min vector</param>
        /// <param name="max">the max vector</param>
        public <#= GetName(Dimension, FloatType) #><T> Clamp(T min, T max) => <#= GetName(Dimension, FloatType) #>.Clamp(this, min, max);
        /// <summary>
        /// For each component, set the value to the absolute value of the component
        /// </summary>
        public <#= GetName(Dimension, FloatType) #><T> Abs() => <#= GetName(Dimension, FloatType) #>.Abs(this);
        /// <summary>
        /// For each component, set the sign to the sign of the matching component from the sign vector
        /// </summary>
        /// <param name="sign">the sign vector</param>
        public <#= GetName(Dimension, FloatType) #><T> CopySign(<#= GetName(Dimension, FloatType) #><T> sign) => <#= GetName(Dimension, FloatType) #>.CopySign(this, sign);
        /// <summary>
        /// For each component, set the sign to the sign of the given scalar
        /// </summary>
        /// <param name="sign">the sign scalar</param>
        public <#= GetName(Dimension, FloatType) #><T> CopySign(T sign) => <#= GetName(Dimension, FloatType) #>.CopySign(this, sign);

        /// <summary>
        /// For each component, set the value to the appropriate sign value
        /// </summary>
        public <#= GetName(Dimension, FloatType) #><T> Sign() => <#= GetName(Dimension, FloatType) #>.Sign(this);

        <#
            for (int i = MinMatRow; i <= MaxMatRow; i++)
            {
                for (int j = MinMatCol; j <= MaxMatCol; j++)
                {#>/// <summary>
        /// Transforms this vector by multiplying it in homogenous space with a given matrix
        /// </summary>
        /// <param name="transform">the transform matrix</param>
        public <#= GetName(Dimension, FloatType) #><T> Transform(Matrix<#=i#>x<#=j#><#=FloatType ? "F" : "I"#><T> transform) => <#= GetName(Dimension, FloatType) #>.Transform(this, transform);
        /// <summary>
        /// Transforms this vector by multiplying it with a given matrix
        /// </summary>
        /// <param name="transform">the transform matrix</param>
        public <#= GetName(Dimension, FloatType) #><T> TransformNormal(Matrix<#=i#>x<#=j#><#=FloatType ? "F" : "I"#><T> transform) => <#= GetName(Dimension, FloatType) #>.TransformNormal(this, transform);
        
        <#
                }
            }#>/// <summary>
        /// Transforms this vector by multiplying it in homogenous space with a given matrix
        /// </summary>
        /// <param name="transform">the transform matrix</param>
        public <#= GetName(Dimension, FloatType) #><T> Transform(Matrix5x4<#=FloatType ? "F" : "I"#><T> transform) => <#= GetName(Dimension, FloatType) #>.Transform(this, transform);
        /// <summary>
        /// Transforms this vector by multiplying it with a given matrix
        /// </summary>
        /// <param name="transform">the transform matrix</param>
        public <#= GetName(Dimension, FloatType) #><T> TransformNormal(Matrix5x4<#=FloatType ? "F" : "I"#><T> transform) => <#= GetName(Dimension, FloatType) #>.TransformNormal(this, transform);
        
        /// <summary>
        /// Reflects this vector across the given normal vector
        /// </summary>
        /// <param name="normal">the normal vector</param>
        public <#= GetName(Dimension, FloatType) #><T> Reflect(<#= GetName(Dimension, FloatType) #><T> normal) => <#= GetName(Dimension, FloatType) #>.Reflect(this, normal);
        /// <summary>Adds two vectors together.</summary>
        /// <param name="lh">The first source vector.</param>
        /// <param name="rh">The second source vector.</param>
        /// <returns>The summed vector.</returns>
        public static <#= GetName(Dimension, FloatType) #><T> operator +(<#= GetName(Dimension, FloatType) #><T> lh, <#= GetName(Dimension, FloatType) #><T> rh)
        {<#if (IsPowerOfTwo(Dimension)){#>
            
            switch (Unsafe.SizeOf<T>())
            {<#
                    for (int size = 1; size <= 32; size <<= 1)
                    {
                        int vectorSize = int.Max(64, size << 3 * Dimension);
                        if (vectorSize > 512) continue; #>

                case <#=size#>:
                    if (Vector<#=vectorSize#><T>.IsSupported && Vector<#=vectorSize#>.IsHardwareAccelerated)
                    {
                        Vector<#=vectorSize#><T> result = lh.ToVector<#=vectorSize#>() + rh.ToVector<#=vectorSize#>();
                        return Unsafe.ReadUnaligned<<#= GetName(Dimension, FloatType) #><T>>(ref Unsafe.As<Vector<#=vectorSize#><T>, byte>(ref result));
                    }
                break;
                <#}#>

                default:
                break;
            }
            <#}#>return new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh.<#=GetComponentName(i)#> + rh.<#=GetComponentName(i)#><#= i < Dimension - 1 ? ", " : ");" #><#}#>

        }

        /// <summary>Subtracts the second vector from the first.</summary>
        /// <param name="lh">The first source vector.</param>
        /// <param name="rh">The second source vector.</param>
        /// <returns>The subtracted vector.</returns>
        public static <#= GetName(Dimension, FloatType) #><T> operator -(<#= GetName(Dimension, FloatType) #><T> lh, <#= GetName(Dimension, FloatType) #><T> rh)
        {<#if (IsPowerOfTwo(Dimension)){#>
            
            switch (Unsafe.SizeOf<T>())
            {<#
                    for (int size = 1; size <= 32; size <<= 1)
                    {
                        int vectorSize = int.Max(64, (size << 3) * Dimension);
                        if (vectorSize > 512) continue; #>

                case <#=size#>:
                    if (Vector<#=vectorSize#><T>.IsSupported && Vector<#=vectorSize#>.IsHardwareAccelerated)
                    {
                        Vector<#=vectorSize#><T> result = lh.ToVector<#=vectorSize#>() - rh.ToVector<#=vectorSize#>();
                        return Unsafe.ReadUnaligned<<#= GetName(Dimension, FloatType) #><T>>(ref Unsafe.As<Vector<#=vectorSize#><T>, byte>(ref result));
                    }
                break;
                <#}#>

                default:
                break;
            }
            <#}#>return new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh.<#=GetComponentName(i)#> - rh.<#=GetComponentName(i)#><#= i < Dimension - 1 ? ", " : ");" #><#}#>

        }

        /// <summary>Multiplies two vectors together.</summary>
        /// <param name="lh">The first source vector.</param>
        /// <param name="rh">The second source vector.</param>
        /// <returns>The multiplied vector.</returns>
        public static <#= GetName(Dimension, FloatType) #><T> operator *(<#= GetName(Dimension, FloatType) #><T> lh, <#= GetName(Dimension, FloatType) #><T> rh)
        {<#if (IsPowerOfTwo(Dimension)){#>
            
            switch (Unsafe.SizeOf<T>())
            {<#
                    for (int size = 1; size <= 32; size <<= 1)
                    {
                        int vectorSize = int.Max(64, (size << 3) * Dimension);
                        if (vectorSize > 512) continue; #>

                case <#=size#>:
                    if (Vector<#=vectorSize#><T>.IsSupported && Vector<#=vectorSize#>.IsHardwareAccelerated)
                    {
                        Vector<#=vectorSize#><T> result = lh.ToVector<#=vectorSize#>() * rh.ToVector<#=vectorSize#>();
                        return Unsafe.ReadUnaligned<<#= GetName(Dimension, FloatType) #><T>>(ref Unsafe.As<Vector<#=vectorSize#><T>, byte>(ref result));
                    }
                break;
                <#}#>

                default:
                break;
            }
            <#}#>return new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh.<#=GetComponentName(i)#> * rh.<#=GetComponentName(i)#><#= i < Dimension - 1 ? ", " : ");" #><#}#>

        }

        /// <summary>Divides the second vector from the first.</summary>
        /// <param name="lh">The first source vector.</param>
        /// <param name="rh">The second source vector.</param>
        /// <returns>The divided vector.</returns>
        public static <#= GetName(Dimension, FloatType) #><T> operator /(<#= GetName(Dimension, FloatType) #><T> lh, <#= GetName(Dimension, FloatType) #><T> rh)
        {<#if (IsPowerOfTwo(Dimension)){#>
            
            switch (Unsafe.SizeOf<T>())
            {<#
                    for (int size = 1; size <= 32; size <<= 1)
                    {
                        int vectorSize = int.Max(64, (size << 3) * Dimension);
                        if (vectorSize > 512) continue; #>

                case <#=size#>:
                    if (Vector<#=vectorSize#><T>.IsSupported && Vector<#=vectorSize#>.IsHardwareAccelerated)
                    {
                        Vector<#=vectorSize#><T> result = lh.ToVector<#=vectorSize#>() / rh.ToVector<#=vectorSize#>();
                        return Unsafe.ReadUnaligned<<#= GetName(Dimension, FloatType) #><T>>(ref Unsafe.As<Vector<#=vectorSize#><T>, byte>(ref result));
                    }
                break;
                <#}#>

                default:
                break;
            }
            <#}#>return new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh.<#=GetComponentName(i)#> / rh.<#=GetComponentName(i)#><#= i < Dimension - 1 ? ", " : ");" #><#}#>

        }

        /// <summary>Divides the second vector from the first and returns the remainder.</summary>
        /// <param name="lh">The first source vector.</param>
        /// <param name="rh">The second source vector.</param>
        /// <returns>The remainder vector.</returns>
        public static <#= GetName(Dimension, FloatType) #><T> operator %(<#= GetName(Dimension, FloatType) #><T> lh, <#= GetName(Dimension, FloatType) #><T> rh) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh.<#=GetComponentName(i)#> % rh.<#=GetComponentName(i)#><#= i < Dimension - 1 ? ", " : ");" #><#
                            }#>

        /// <summary>
        /// Negates the vector
        /// </summary>
        /// <param name="val">the source vector</param>
        /// <returns>the negated vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> operator -(<#= GetName(Dimension, FloatType) #><T> val) => Zero - val;
        /// <summary>
        /// Returns the vector
        /// </summary>
        /// <param name="val">the source vector</param>
        /// <returns>the vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> operator +(<#= GetName(Dimension, FloatType) #><T> val) => val;

        /// <summary>Adds a scalar to the vector component-wise.</summary>
        /// <param name="lh">The source vector.</param>
        /// <param name="rh">The source scalar.</param>
        /// <returns>The summed vector.</returns>
        public static <#= GetName(Dimension, FloatType) #><T> operator +(<#= GetName(Dimension, FloatType) #><T> lh, T rh) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh.<#=GetComponentName(i)#> + rh<#= i < Dimension - 1 ? ", " : ");" #><#}#>

        /// <summary>Subtracts a scalar from the vector component-wise.</summary>
        /// <param name="lh">The source vector.</param>
        /// <param name="rh">The source scalar.</param>
        /// <returns>The subtracted vector.</returns>
        public static <#= GetName(Dimension, FloatType) #><T> operator -(<#= GetName(Dimension, FloatType) #><T> lh, T rh) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh.<#=GetComponentName(i)#> - rh<#= i < Dimension - 1 ? ", " : ");" #><#}#>

        /// <summary>Multiplies a scalar to the vector component-wise.</summary>
        /// <param name="lh">The source vector.</param>
        /// <param name="rh">The source scalar.</param>
        /// <returns>The multiplied vector.</returns>
        public static <#= GetName(Dimension, FloatType) #><T> operator *(<#= GetName(Dimension, FloatType) #><T> lh, T rh) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh.<#=GetComponentName(i)#> * rh<#= i < Dimension - 1 ? ", " : ");" #><#}#>

        /// <summary>Divides a vector component-wise by a scalar.</summary>
        /// <param name="lh">The source vector.</param>
        /// <param name="rh">The source scalar.</param>
        /// <returns>The divided vector.</returns>
        public static <#= GetName(Dimension, FloatType) #><T> operator /(<#= GetName(Dimension, FloatType) #><T> lh, T rh) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh.<#=GetComponentName(i)#> / rh<#= i < Dimension - 1 ? ", " : ");" #><#}#>

        /// <summary>Divides a vector component-wise by a scalar and returns the remainders.</summary>
        /// <param name="lh">The source vector.</param>
        /// <param name="rh">The source scalar.</param>
        /// <returns>The remainder vector.</returns>
        public static <#= GetName(Dimension, FloatType) #><T> operator %(<#= GetName(Dimension, FloatType) #><T> lh, T rh) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh.<#=GetComponentName(i)#> % rh<#= i < Dimension - 1 ? ", " : ");" #><#}#>

        /// <summary>Adds a scalar to the vector component-wise.</summary>
        /// <param name="lh">The source scalar.</param>
        /// <param name="rh">The source vector.</param>
        /// <returns>The summed vector.</returns>
        public static <#= GetName(Dimension, FloatType) #><T> operator +(T lh, <#= GetName(Dimension, FloatType) #><T> rh) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh + rh.<#=GetComponentName(i)#><#= i < Dimension - 1 ? ", " : ");" #><#}#>

        /// <summary>Subtracts a scalar from the vector component-wise.</summary>
        /// <param name="lh">The source scalar.</param>
        /// <param name="rh">The source vector.</param>
        /// <returns>The subtracted vector.</returns>
        public static <#= GetName(Dimension, FloatType) #><T> operator -(T lh, <#= GetName(Dimension, FloatType) #><T> rh) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh - rh.<#=GetComponentName(i)#><#= i < Dimension - 1 ? ", " : ");" #><#}#>

        /// <summary>Multiplies a scalar to the vector component-wise.</summary>
        /// <param name="lh">The source scalar.</param>
        /// <param name="rh">The source vector.</param>
        /// <returns>The multiplied vector.</returns>
        public static <#= GetName(Dimension, FloatType) #><T> operator *(T lh, <#= GetName(Dimension, FloatType) #><T> rh) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh * rh.<#=GetComponentName(i)#><#= i < Dimension - 1 ? ", " : ");" #><#}#>

        /// <summary>Divides a vector component-wise by a scalar.</summary>
        /// <param name="lh">The source scalar.</param>
        /// <param name="rh">The source vector.</param>
        /// <returns>The divided vector.</returns>
        public static <#= GetName(Dimension, FloatType) #><T> operator /(T lh, <#= GetName(Dimension, FloatType) #><T> rh) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh / rh.<#=GetComponentName(i)#><#= i < Dimension - 1 ? ", " : ");" #><#}#>

        /// <summary>Divides a vector component-wise by a scalar and returns the remainders.</summary>
        /// <param name="lh">The source scalar.</param>
        /// <param name="rh">The source vector.</param>
        /// <returns>The remainder vector.</returns>
        public static <#= GetName(Dimension, FloatType) #><T> operator %(T lh, <#= GetName(Dimension, FloatType) #><T> rh) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh % rh.<#=GetComponentName(i)#><#= i < Dimension - 1 ? ", " : ");" #><#}#>

        /// <summary>Returns a boolean indicating whether the two given vectors are equal.</summary>
        /// <param name="lh">The first vector to compare.</param>
        /// <param name="rh">The second vector to compare.</param>
        /// <returns>True if the vectors are equal; False otherwise.</returns>
        public static bool operator ==(<#= GetName(Dimension, FloatType) #><T> lh, <#= GetName(Dimension, FloatType) #><T> rh) => <#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh.<#=GetComponentName(i)#> == rh.<#=GetComponentName(i)#><#= i < Dimension - 1 ? " && " : ";" #><#}#>

        /// <summary>Returns a boolean indicating whether the two given vectors are not equal.</summary>
        /// <param name="lh">The first vector to compare.</param>
        /// <param name="rh">The second vector to compare.</param>
        /// <returns>True if the vectors are not equal; False if they are equal.</returns>
        public static bool operator !=(<#= GetName(Dimension, FloatType) #><T> lh, <#= GetName(Dimension, FloatType) #><T> rh) => <#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh.<#=GetComponentName(i)#> != rh.<#=GetComponentName(i)#><#= i < Dimension - 1 ? " || " : ";" #><#}#>

        #endregion

        #region Equality
        /// <summary>Returns a boolean indicating whether this vector and the given vector are equal</summary>
        /// <param name="other">The vector to compare this instance to.</param>
        /// <returns>True if the other vector is equal to this instance; False otherwise.</returns>
        public bool Equals(<#= GetName(Dimension, FloatType) #><T> other) => <#
                            for (int i = 0; i < Dimension; i++)
                            {#><#=GetComponentName(i)#>.Equals(other.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? " && " : ";" #><#}#>


        /// <summary>Returns a boolean indicating whether the given Object is equal to this vector instance.</summary>
        /// <param name="obj">The Object to compare against.</param>
        /// <returns>True if the Object is equal to this Vector2D; False otherwise.</returns>
        public override bool Equals([NotNullWhen(true)] object? obj) => (obj is <#= GetName(Dimension, FloatType) #><T> other) && Equals(other);

        /// <summary>Returns a boolean indicating whether this vector and the given vector are equal</summary>
        /// <param name="other">The vector to compare this instance to.</param>
        /// <returns>True if the other vector is equal to this instance; False otherwise.</returns>
        public bool Equals(Vector<#=Dimension#> other)
        {<#if (FloatType)
                {#>

            if (typeof(T) == typeof(float))
            {
                if (Vector128.IsHardwareAccelerated)
                {
                    return Unsafe.BitCast<<#= GetName(Dimension, FloatType) #><T>, Vector2>(this).AsVector128().Equals(other.AsVector128());
                }
                else
                {
                    return Unsafe.BitCast<<#= GetName(Dimension, FloatType) #><T>, Vector2>(this).Equals(other);
                }
            }<#
                }#>

            return <#for (int i = 0; i < Dimension; i++){#><#=GetComponentName(i)#>.Equals(other.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? " && " : ";" #><#
                            }#>

        }

        /// <inheritdoc/>
        public override int GetHashCode() => HashCode.Combine(<#
                            for (int i = 0; i < Dimension; i++)
                            {#><#=GetComponentName(i)#><#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        #endregion

        #region Vector Conversions
        /// <summary>
        /// Converts this vector into a <see cref="Vector64{T}"/>
        /// </summary>
        /// <returns>the <see cref="Vector64{T}"/></returns>
        public Vector64<T> ToVector64()
        {
            if (Count >= Vector64<T>.Count)
            {
                return Vector64.Create<T>(AsSpan());
            }

            T* array = stackalloc T[Vector64<T>.Count];
            for (int i = 0; i < Count; i++)
            {
                array[i] = this[i];
            }

            return Vector64.Create<T>(new Span<T>(array, Vector64<T>.Count));
        }

        /// <summary>
        /// Converts this vector into a <see cref="Vector128{T}"/>
        /// </summary>
        /// <returns>the <see cref="Vector128{T}"/></returns>
        public Vector128<T> ToVector128()
        {
            if (Count >= Vector128<T>.Count)
            {
                return Vector128.Create<T>(AsSpan());
            }

            T* array = stackalloc T[Vector128<T>.Count];
            for (int i = 0; i < Count; i++)
            {
                array[i] = this[i];
            }

            return Vector128.Create<T>(new Span<T>(array, Vector128<T>.Count));
        }

        /// <summary>
        /// Converts this vector into a <see cref="Vector256{T}"/>
        /// </summary>
        /// <returns>the <see cref="Vector256{T}"/></returns>
        public Vector256<T> ToVector256()
        {
            if (Count >= Vector256<T>.Count)
            {
                return Vector256.Create<T>(AsSpan());
            }

            T* array = stackalloc T[Vector256<T>.Count];
            for (int i = 0; i < Count; i++)
            {
                array[i] = this[i];
            }

            return Vector256.Create<T>(new Span<T>(array, Vector256<T>.Count));
        }

        /// <summary>
        /// Converts this vector into a <see cref="Vector512{T}"/>
        /// </summary>
        /// <returns>the <see cref="Vector512{T}"/></returns>
        public Vector512<T> ToVector512()
        {
            if (Count >= Vector512<T>.Count)
            {
                return Vector512.Create<T>(AsSpan());
            }

            T* array = stackalloc T[Vector512<T>.Count];
            for (int i = 0; i < Count; i++)
            {
                array[i] = this[i];
            }

            return Vector512.Create<T>(new Span<T>(array, Vector512<T>.Count));
        }

        //Floating Point Conversions
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, true) #>{Half}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator <#= GetName(Dimension, true) #><Half>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>Half.CreateTruncating(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, true) #>{Single}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator <#= GetName(Dimension, true) #><float>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>float.CreateTruncating(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, true) #>{Double}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator <#= GetName(Dimension, true) #><double>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>double.CreateTruncating(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, true) #>{NFloat}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator <#= GetName(Dimension, true) #><NFloat>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>NFloat.CreateTruncating(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);

        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, true) #>{Half}"/> and checks for overflow
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator checked <#= GetName(Dimension, true) #><Half>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>Half.CreateChecked(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, true) #>{Single}"/> and checks for overflow
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator checked <#= GetName(Dimension, true) #><float>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>float.CreateChecked(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, true) #>{Double}"/> and checks for overflow
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator checked <#= GetName(Dimension, true) #><double>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>double.CreateChecked(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, true) #>{NFloat}"/> and checks for overflow
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator checked <#= GetName(Dimension, true) #><NFloat>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>NFloat.CreateChecked(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);

        /// <summary>
        /// Converts the specified floating point vector to this vector type, checking for overflow
        /// </summary>
        /// <typeparam name="TOther">the other scalar type</typeparam>
        /// <param name="value">the source vector</param>
        /// <returns>the converted vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> CreateChecked<TOther>(<#= GetName(Dimension, true) #><TOther> value) where TOther : unmanaged, IFloatingPointIeee754<TOther> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.CreateChecked(value.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified floating point vector to this vector type, saturating any values outside of the valid range
        /// </summary>
        /// <typeparam name="TOther">the other scalar type</typeparam>
        /// <param name="value">the source vector</param>
        /// <returns>the converted vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> CreateSaturating<TOther>(<#= GetName(Dimension, true) #><TOther> value) where TOther : unmanaged, IFloatingPointIeee754<TOther> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.CreateSaturating(value.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified floating point vector to this vector type, truncating any values outside of the valid range
        /// </summary>
        /// <typeparam name="TOther">the other scalar type</typeparam>
        /// <param name="value">the source vector</param>
        /// <returns>the converted vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> CreateTruncating<TOther>(<#= GetName(Dimension, true) #><TOther> value) where TOther : unmanaged, IFloatingPointIeee754<TOther> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.CreateTruncating(value.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);

        //Binary Integer Conversions
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{Byte}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator <#= GetName(Dimension, false) #><byte>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>byte.CreateTruncating(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{SByte}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator <#= GetName(Dimension, false) #><sbyte>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>sbyte.CreateTruncating(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{UInt16}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator <#= GetName(Dimension, false) #><ushort>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>ushort.CreateTruncating(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{Int16}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator <#= GetName(Dimension, false) #><short>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>short.CreateTruncating(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{UInt32}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator <#= GetName(Dimension, false) #><uint>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>uint.CreateTruncating(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{Int32}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator <#= GetName(Dimension, false) #><int>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>int.CreateTruncating(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{UInt64}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator <#= GetName(Dimension, false) #><ulong>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>ulong.CreateTruncating(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{Int64}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator <#= GetName(Dimension, false) #><long>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>long.CreateTruncating(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{UInt128}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator <#= GetName(Dimension, false) #><UInt128>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>UInt128.CreateTruncating(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{Int128}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator <#= GetName(Dimension, false) #><Int128>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>Int128.CreateTruncating(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{nuint}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator <#= GetName(Dimension, false) #><nuint>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>nuint.CreateTruncating(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{nint}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator <#= GetName(Dimension, false) #><nint>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>nint.CreateTruncating(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);

        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{Byte}"/> and checking for overflow
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator checked <#= GetName(Dimension, false) #><byte>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>byte.CreateChecked(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{SByte}"/> and checking for overflow
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator checked <#= GetName(Dimension, false) #><sbyte>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>sbyte.CreateChecked(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{UInt16}"/> and checking for overflow
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator checked <#= GetName(Dimension, false) #><ushort>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>ushort.CreateChecked(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{Int16}"/> and checking for overflow
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator checked <#= GetName(Dimension, false) #><short>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>short.CreateChecked(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{UInt32}"/> and checking for overflow
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator checked <#= GetName(Dimension, false) #><uint>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>uint.CreateChecked(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{Int32}"/> and checking for overflow
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator checked <#= GetName(Dimension, false) #><int>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>int.CreateChecked(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{UInt64}"/> and checking for overflow
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator checked <#= GetName(Dimension, false) #><ulong>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>ulong.CreateChecked(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{Int64}"/> and checking for overflow
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator checked <#= GetName(Dimension, false) #><long>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>long.CreateChecked(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{UInt128}"/> and checking for overflow
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator checked <#= GetName(Dimension, false) #><UInt128>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>UInt128.CreateChecked(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{Int128}"/> and checking for overflow
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator checked <#= GetName(Dimension, false) #><Int128>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>Int128.CreateChecked(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{nuint}"/> and checking for overflow
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator checked <#= GetName(Dimension, false) #><nuint>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>nuint.CreateChecked(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, false) #>{nint}"/> and checking for overflow
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator checked <#= GetName(Dimension, false) #><nint>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>nint.CreateChecked(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);

        /// <summary>
        /// Converts the specified binary integer vector to this vector type, checking for overflow
        /// </summary>
        /// <typeparam name="TOther">the other scalar type</typeparam>
        /// <param name="value">the source vector</param>
        /// <returns>the converted vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> CreateChecked<TOther>(<#= GetName(Dimension, false) #><TOther> value) where TOther : unmanaged, IBinaryInteger<TOther> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.CreateChecked(value.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified binary integer vector to this vector type, saturating any values outside of the valid range
        /// </summary>
        /// <typeparam name="TOther">the other scalar type</typeparam>
        /// <param name="value">the source vector</param>
        /// <returns>the converted vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> CreateSaturating<TOther>(<#= GetName(Dimension, false) #><TOther> value) where TOther : unmanaged, IBinaryInteger<TOther> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.CreateSaturating(value.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified binary integer vector to this vector type, truncating any values outside of the valid range
        /// </summary>
        /// <typeparam name="TOther">the other scalar type</typeparam>
        /// <param name="value">the source vector</param>
        /// <returns>the converted vector</returns>
        public static <#= GetName(Dimension, FloatType) #><T> CreateTruncating<TOther>(<#= GetName(Dimension, false) #><TOther> value) where TOther : unmanaged, IBinaryInteger<TOther> => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.CreateTruncating(value.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);

        //System.Numerics Conversions

        <# if (Dimension < 5 && Dimension > 1)
        {#>/// <summary>
        /// Converts the specified vector into a <see cref="Vector<#=Dimension#>"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator Vector<#=Dimension#>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>float.CreateTruncating(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, FloatType) #>{T}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator <#= GetName(Dimension, FloatType) #><T>(Vector<#=Dimension#> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.CreateTruncating(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);

        /// <summary>
        /// Converts the specified vector into a <see cref="Vector<#=Dimension#>"/> and checking for overflow
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator checked Vector<#=Dimension#>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>float.CreateChecked(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(Dimension, FloatType) #>{T}"/> and checking for overflow
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator checked <#= GetName(Dimension, FloatType) #><T>(Vector<#=Dimension#> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>T.CreateChecked(val.<#=GetComponentName(i)#>)<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        <#}#>

        /// <summary>
        /// Converts the specified vector into a <see cref="Vector64{T}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator Vector64<T>(<#= GetName(Dimension, FloatType) #><T> val) => val.ToVector64();
        /// <summary>
        /// Converts the specified vector into a <see cref="Vector128{T}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator Vector128<T>(<#= GetName(Dimension, FloatType) #><T> val) => val.ToVector128();
        /// <summary>
        /// Converts the specified vector into a <see cref="Vector256{T}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator Vector256<T>(<#= GetName(Dimension, FloatType) #><T> val) => val.ToVector256();
        /// <summary>
        /// Converts the specified vector into a <see cref="Vector512{T}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator Vector512<T>(<#= GetName(Dimension, FloatType) #><T> val) => val.ToVector512();

        //lower dimension Conversions
        <#for (int dim = MinDim; dim < Dimension; dim++)
            {#>/// <summary>
        /// Converts the specified vector into a <see cref="<#= GetName(dim, FloatType) #>{T}"/>
        /// </summary>
        /// <param name="val">the source vector</param>
        public static explicit operator <#= GetName(dim, FloatType) #><T>(<#= GetName(Dimension, FloatType) #><T> val) => new(<#
                            for (int i = 0; i < dim; i++)
                            {#><#=GetComponentName(i)#><#= i < dim - 1 ? ", " : "" #><#
                            }#>);
        <#}#>

        #endregion

        #region List
        /// <inheritdoc/>
        T IReadOnlyList<T>.this[int index] => AsSpan()[index];

        /// <inheritdoc/>
        public IEnumerator<T> GetEnumerator() => new Enumerator(this);

        /// <inheritdoc/>
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        private class Enumerator(<#= GetName(Dimension, FloatType) #><T> Vector) : IEnumerator<T>
        {
            private int _index = -1;

            /// <inheritdoc/>
            public T Current => Vector[_index];

            /// <inheritdoc/>
            object IEnumerator.Current => Current;

            /// <inheritdoc/>
            public void Dispose() { }

            /// <inheritdoc/>
            public bool MoveNext()
            {
                _index++;
                return _index >= Vector.Count;
            }

            /// <inheritdoc/>
            public void Reset() => _index = -1;
        }
        #endregion

        #region Format
        /// <summary>Returns the string representation of the current instance using default formatting.</summary>
        /// <returns>The string representation of the current instance.</returns>
        /// <remarks>This method returns a string in which each element of the vector is formatted using the "G" (general) format string and the formatting conventions of the current thread culture. The "&lt;" and "&gt;" characters are used to begin and end the string, and the current culture's <see cref="NumberFormatInfo.NumberGroupSeparator" /> property followed by a space is used to separate each element.</remarks>
        public override string ToString()
        {
            return ToString("G", null);
        }

        /// <summary>Returns the string representation of the current instance using the specified format string to format individual elements.</summary>
        /// <param name="format">A standard or custom numeric format string that defines the format of individual elements.</param>
        /// <returns>The string representation of the current instance.</returns>
        /// <remarks>This method returns a string in which each element of the vector is formatted using <paramref name="format" /> and the current culture's formatting conventions. The "&lt;" and "&gt;" characters are used to begin and end the string, and the current culture's <see cref="NumberFormatInfo.NumberGroupSeparator" /> property followed by a space is used to separate each element.</remarks>
        /// <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standard Numeric Format Strings</related>
        /// <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Custom Numeric Format Strings</related>
        public string ToString([StringSyntax(StringSyntaxAttribute.NumericFormat)] string? format)
        {
            return ToString(format, null);
        }

        /// <summary>Returns the string representation of the current instance using the specified format string to format individual elements and the specified format provider to define culture-specific formatting.</summary>
        /// <param name="format">A standard or custom numeric format string that defines the format of individual elements.</param>
        /// <param name="formatProvider">A format provider that supplies culture-specific formatting information.</param>
        /// <returns>The string representation of the current instance.</returns>
        /// <remarks>This method returns a string in which each element of the vector is formatted using <paramref name="format" /> and <paramref name="formatProvider" />. The "&lt;" and "&gt;" characters are used to begin and end the string, and the format provider's <see cref="NumberFormatInfo.NumberGroupSeparator" /> property followed by a space is used to separate each element.</remarks>
        /// <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standard Numeric Format Strings</related>
        /// <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Custom Numeric Format Strings</related>
        public string ToString([StringSyntax(StringSyntaxAttribute.NumericFormat)] string? format, IFormatProvider? formatProvider)
        {
            string separator = NumberFormatInfo.GetInstance(formatProvider).NumberGroupSeparator;

            Span<char> initialBuffer = stackalloc char[Math.Min((2 + (Count - 1) + (separator.Length * (Count - 1)) + (Count * 2)), 256)];

            // We can't use an interpolated string here because it won't allow us to pass `format`
            DefaultInterpolatedStringHandler handler = new(
                4 + (separator.Length * 2),
                Count,
                formatProvider,
                initialBuffer
            );

            handler.AppendLiteral("(");<#
                for (int i = 0; i < Dimension; i++)
                {#>

            handler.AppendFormatted(<#=GetComponentName(i)#>, format);<# if (i < Dimension - 1)
                {#>

            handler.AppendLiteral(separator);
            handler.AppendLiteral(" ");<#}
                }#>

            handler.AppendLiteral(")");

            return handler.ToStringAndClear();
        }

        /// <inheritdoc/>
        public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        {
            string separator = NumberFormatInfo.GetInstance(provider).NumberGroupSeparator;

            // We can't use an interpolated string here because it won't allow us to pass `format`
            MemoryExtensions.TryWriteInterpolatedStringHandler handler = new(
                4 + (separator.Length * 2),
                Count,
                destination,
                provider,
                out bool shouldAppend
            );
            if (!shouldAppend)
            {
                charsWritten = 0;
                return false;
            }

            // Annoyingly we need to turn the span into a string for the string handler
            string? formatString = format.Length > 0 ? new string(format) : null;

            _ =
                handler.AppendLiteral("(") &&<#
                for (int i = 0; i < Dimension; i++)
                {#>

            handler.AppendFormatted(<#=GetComponentName(i)#>, formatString) &&<# if (i < Dimension - 1)
                    {#>

            handler.AppendLiteral(separator) &&
            handler.AppendLiteral(" ") &&<#
                        }
                    }#>

            handler.AppendLiteral(")");

            return destination.TryWrite(ref handler, out charsWritten);
        }

        /// <inheritdoc/>
        public bool TryFormat(Span<byte> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider? provider)
        {
            charsWritten = 0;
            byte[] openBracket = Encoding.UTF8.GetBytes("(");
            byte[] separator = Encoding.UTF8.GetBytes(NumberFormatInfo.GetInstance(provider).NumberGroupSeparator);
            byte[] space = Encoding.UTF8.GetBytes(" ");
            byte[] closeBracket = Encoding.UTF8.GetBytes(")");

            <#
                for (int i = 0; i < Dimension; i++)
                {#>
                
            byte[] <#=GetComponentName(i, false)#>Bytes = Encoding.UTF8.GetBytes(<#=GetComponentName(i)#>.ToString(new(format), provider));
            charsWritten += <#=GetComponentName(i, false)#>Bytes.Length;<#
                    }#>

            charsWritten += separator.Length + openBracket.Length + closeBracket.Length + space.Length;

            if (charsWritten > destination.Length)
            {
                charsWritten = 0;
                return false;
            }

            charsWritten = 0;
            for (int i = 0; i < openBracket.Length; i++)
                destination[charsWritten++] = openBracket[i];<#
                for (int i = 0; i < Dimension; i++)
                {#>

            for (int i = 0; i < <#=GetComponentName(i, false)#>Bytes.Length; i++)
                destination[charsWritten++] = <#=GetComponentName(i, false)#>Bytes[i];<# 
                    if (i < Dimension - 1)
                    {#>

            for (int i = 0; i < separator.Length; i++)
                destination[charsWritten++] = separator[i];
            for (int i = 0; i < space.Length; i++)
                destination[charsWritten++] = space[i];<#
                        }
                    }#>

            for (int i = 0; i < closeBracket.Length; i++)
                destination[charsWritten++] = closeBracket[i];

            return true;
        }
        #endregion

        #region Parse
        /// <inheritdoc/>
        static <#= GetName(Dimension, FloatType) #><T> IParsable<<#= GetName(Dimension, FloatType) #><T>>.Parse(string s, IFormatProvider? provider)
            => Parse(s.AsSpan(), NumberStyles.None, provider);

        /// <inheritdoc/>
        static <#= GetName(Dimension, FloatType) #><T> ISpanParsable<<#= GetName(Dimension, FloatType) #><T>>.Parse(ReadOnlySpan<char> s, IFormatProvider? provider)
            => Parse(s, NumberStyles.None, provider);

        /// <inheritdoc/>
        static <#= GetName(Dimension, FloatType) #><T> IUtf8SpanParsable<<#= GetName(Dimension, FloatType) #><T>>.Parse(ReadOnlySpan<byte> s, IFormatProvider? provider)
            => Parse(s, NumberStyles.None, provider);

        /// <inheritdoc/>
        public static <#= GetName(Dimension, FloatType) #><T> Parse(string s, NumberStyles style = default, IFormatProvider? provider = null)
            => Parse(s.AsSpan(), style, provider);

        /// <inheritdoc/>
        public static <#= GetName(Dimension, FloatType) #><T> Parse(ReadOnlySpan<char> s, NumberStyles style = NumberStyles.None, IFormatProvider? provider = null)
            => TryParse(s, style, provider, out var result) ? result : throw new ArgumentException($"Failed to parse {nameof(<#= GetName(Dimension, FloatType) #><T>)}<{typeof(T)}>");

        /// <inheritdoc/>
        public static <#= GetName(Dimension, FloatType) #><T> Parse(ReadOnlySpan<byte> s, NumberStyles style = NumberStyles.None, IFormatProvider? provider = null)
            => TryParse(s, style, provider, out var result) ? result : throw new ArgumentException($"Failed to parse {nameof(<#= GetName(Dimension, FloatType) #><T>)}<{typeof(T)}>");

        /// <inheritdoc/>
        public static bool TryParse(string? s, IFormatProvider? provider, out <#= GetName(Dimension, FloatType) #><T> result)
            => TryParse(s.AsSpan(), NumberStyles.None, provider, out result);

        /// <inheritdoc/>
        public static bool TryParse(string? s, NumberStyles style, IFormatProvider? provider, out <#= GetName(Dimension, FloatType) #><T> result)
            => TryParse(s.AsSpan(), style, provider, out result);

        /// <inheritdoc/>
        public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out <#= GetName(Dimension, FloatType) #><T> result)
            => TryParse(s, NumberStyles.None, provider, out result);

        /// <inheritdoc/>
        public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider? provider, out <#= GetName(Dimension, FloatType) #><T> result)
        {
            result = default;

            if (s[0] != '(')
                return false;
            if (s[^1] != ')')
                return false;

            string separator = NumberFormatInfo.GetInstance(provider).NumberGroupSeparator;

            s = s[1..^1];
            <#
                for (int i = 0; i < Dimension; i++)
            {#>
            
            T <#=GetComponentName(i, false)#>;<# if (i < Dimension - 1)
                    {#>

            {
                if (s.Length == 0)
                    return false;

                int nextNumber = s.IndexOf(separator);
                if (nextNumber == -1)
                {
                    return false;
                }

                if (!T.TryParse(s[..nextNumber], style, provider, out <#=GetComponentName(i, false)#>))
                    return false;

                s = s[(nextNumber + separator.Length)..];
            }<#}
            else
            {#>

            {
                if (s.Length == 0)
                    return false;

                if (!T.TryParse(s, style, provider, out <#=GetComponentName(i, false)#>))
                    return false;
            }<#
                }
            }#>


            result = new <#= GetName(Dimension, FloatType) #><T>(<#
                            for (int i = 0; i < Dimension; i++)
                            {#><#=GetComponentName(i, false)#><#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
            return true;
        }

        /// <inheritdoc/>
        public static bool TryParse(ReadOnlySpan<byte> s, IFormatProvider? provider, out <#= GetName(Dimension, FloatType) #><T> result)
            => TryParse(s, NumberStyles.None, provider, out result);

        /// <inheritdoc/>
        public static bool TryParse(ReadOnlySpan<byte> s, NumberStyles style, IFormatProvider? provider, out <#= GetName(Dimension, FloatType) #><T> result)
        {
            result = default;

            if (s[0] != '(')
                return false;
            if (s[^1] != ')')
                return false;

            byte[]? separator = Encoding.UTF8.GetBytes(NumberFormatInfo.GetInstance(provider).NumberGroupSeparator);

            s = s[1..^1];
            <#
                for (int i = 0; i < Dimension; i++)
                {#>

            T <#=GetComponentName(i, false)#>;<# if (i < Dimension - 1)
            {#>

            {
                if (s.Length == 0)
                    return false;

                int nextNumber = s.IndexOf(separator);
                if (nextNumber == -1)
                {
                    return false;
                }

                if (!T.TryParse(s[..nextNumber], style, provider, out <#=GetComponentName(i, false)#>))
                    return false;

                s = s[(nextNumber + separator.Length)..];
            }<#}
            else
            {#>

            {
                if (s.Length == 0)
                    return false;

                if (!T.TryParse(s, style, provider, out <#=GetComponentName(i, false)#>))
                    return false;
            }<#
                }
            }#>


            result = new <#= GetName(Dimension, FloatType) #><T>(<#
                            for (int i = 0; i < Dimension; i++)
                            {#><#=GetComponentName(i, false)#><#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
            return true;
        }
        #endregion

        #region Swizzle
        /// <summary>
        /// Get the swizzle operators for this vector
        /// </summary>
        public SwizzleOperators Swizzle => new (ref Unsafe.AsRef(in this));

        /// <summary>
        /// A structure that handles swizzle operations for this vector
        /// </summary>
        public ref struct SwizzleOperators
        {
            private ref <#= GetName(Dimension, FloatType) #><T> _vector;

            /// <summary>
            /// Creates a Swizzle operator from the given vector
            /// </summary>
            /// <param name="vector">the source vector</param>
            public SwizzleOperators(ref <#= GetName(Dimension, FloatType) #><T> vector)
            {
                _vector = ref vector;
            }

            <#
                for (int destDim = MinDim; destDim <= MaxDim; destDim++)
                {
                    int[] indices = new int[destDim];
                    while(true)
                    {#>
            /// <summary>
            /// retrieve a <see cref="<#= GetName(destDim, FloatType) #>{T}"/> whose components are (<#=GetSwizzleName(indices, ", ")#>)
            /// when assigned to components are assigned based on the first matching component
            /// </summary>
            public <#= GetName(destDim, FloatType) #><T> <#=GetSwizzleName(indices, "")#>
            {
                get => new(_vector.<#=GetSwizzleName(indices, ", _vector.")#>);
                <#if (!Immutable) {#>set
                {<#
                        bool[] found = new bool[Dimension];
                        for (int i = 0; i < indices.Length; i++)
                        {
                            if (found[indices[i]])
                                continue;
                            found[indices[i]] = true; #>

                    _vector.<#=GetComponentName(indices[i])#> = value.<#=GetComponentName(i)#>;<#
                        }}#>

                }
            }<#
                        
                        int index = 0;
                        while (++indices[index] == Dimension)
                        {
                            indices[index++] = 0;

                            if (index >= indices.Length)
                                break;
                        }
                        if (index >= indices.Length)
                                break;
                    }
                }#>

        }
        #endregion

<#
    if (FloatType)
    {#>
        #region Floating Point Specific
        /// <summary>
        /// the length of the vector
        /// </summary>
        public T Length => T.Sqrt(LengthSquared);

        /// <summary>
        /// Gets a vector whose components are all equal to Positive Infinity
        /// </summary>
        public static <#= GetName(Dimension, FloatType) #><T> PositiveInfinity => new(T.PositiveInfinity);
        /// <summary>
        /// Gets a vector whose components are all equal to Negative Infinity
        /// </summary>
        public static <#= GetName(Dimension, FloatType) #><T> NegativeInfinity => new(T.NegativeInfinity);
        /// <summary>
        /// Gets a vector whose components are all equal to NaN
        /// </summary>
        public static <#= GetName(Dimension, FloatType) #><T> NaN => new(T.NaN);
        /// <summary>
        /// Gets a vector whose components are all equal to Epsilon
        /// </summary>
        public static <#= GetName(Dimension, FloatType) #><T> Epsilon => new(T.Epsilon);
        /// <summary>
        /// Gets a vector whose components are all equal to Negative Zero
        /// </summary>
        public static <#= GetName(Dimension, FloatType) #><T> NegativeZero => new(T.NegativeZero);
        /// <summary>
        /// Gets a vector whose components are all equal to Pi
        /// </summary>
        public static <#= GetName(Dimension, FloatType) #><T> Pi => new(T.Pi);
        /// <summary>
        /// Gets a vector whose components are all equal to Tau
        /// </summary>
        public static <#= GetName(Dimension, FloatType) #><T> Tau => new(T.Tau);
        /// <summary>
        /// Gets a vector whose components are all equal to E
        /// </summary>
        public static <#= GetName(Dimension, FloatType) #><T> E => new(T.E);

        /// <summary>
        /// Normalizes this vector so that its length is equal to one
        /// </summary>
        public <#= GetName(Dimension, FloatType) #><T> Normalize() => <#= GetName(Dimension, FloatType) #>.Normalize(this);
        #endregion
<#
    }
    else
    {#>
        #region Integer Specific
        /// <summary>
        /// Gets a vector whose components are all integers with all bits set
        /// </summary>
        public static <#= GetName(Dimension, false) #><T> AllBitsSet => new(T.AllBitsSet);

        /// <summary>
        /// And the components of the source vectors
        /// </summary>
        /// <param name="lh">the first source vector</param>
        /// <param name="rh">the second source vector</param>
        /// <returns>the anded vector</returns>
        public static <#= GetName(Dimension, false) #><T> operator &(<#= GetName(Dimension, false) #><T> lh,  <#= GetName(Dimension, false) #><T> rh) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh.<#=GetComponentName(i)#> & rh.<#=GetComponentName(i)#><#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Or the components of the source vectors
        /// </summary>
        /// <param name="lh">the first source vector</param>
        /// <param name="rh">the second source vector</param>
        /// <returns>the or'd vector</returns>
        public static <#= GetName(Dimension, false) #><T> operator |(<#= GetName(Dimension, false) #><T> lh, <#= GetName(Dimension, false) #><T> rh) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh.<#=GetComponentName(i)#> | rh.<#=GetComponentName(i)#><#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// XOR the components of the source vectors
        /// </summary>
        /// <param name="lh">the first source vector</param>
        /// <param name="rh">the second source vector</param>
        /// <returns>the xor'd vector</returns>
        public static <#= GetName(Dimension, false) #><T> operator ^(<#= GetName(Dimension, false) #><T> lh, <#= GetName(Dimension, false) #><T> rh) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh.<#=GetComponentName(i)#> ^ rh.<#=GetComponentName(i)#><#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);

        /// <summary>
        /// And the components of the source vector with the source scalar
        /// </summary>
        /// <param name="lh">the source vector</param>
        /// <param name="rh">the source scalar</param>
        /// <returns>the anded vector</returns>
        public static <#= GetName(Dimension, false) #><T> operator &(<#= GetName(Dimension, false) #><T> lh, T rh) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh.<#=GetComponentName(i)#> & rh.<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Or the components of the source vector with the source scalar
        /// </summary>
        /// <param name="lh">the source vector</param>
        /// <param name="rh">the source scalar</param>
        /// <returns>the or'd vector</returns>
        public static <#= GetName(Dimension, false) #><T> operator |(<#= GetName(Dimension, false) #><T> lh, T rh) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh.<#=GetComponentName(i)#> | rh.<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// XOR the components of the source vector with the source scalar
        /// </summary>
        /// <param name="lh">the source vector</param>
        /// <param name="rh">the source scalar</param>
        /// <returns>the xor'd vector</returns>
        public static <#= GetName(Dimension, false) #><T> operator ^(<#= GetName(Dimension, false) #><T> lh, T rh) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh.<#=GetComponentName(i)#> ^ rh.<#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);

        /// <summary>
        /// And the components of the source vector with the source scalar
        /// </summary>
        /// <param name="lh">the source scalar</param>
        /// <param name="rh">the source vector</param>
        /// <returns>the anded vector</returns>
        public static <#= GetName(Dimension, false) #><T> operator &(T lh, <#= GetName(Dimension, false) #><T> rh) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh & rh.<#=GetComponentName(i)#><#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// Or the components of the source vector with the source scalar
        /// </summary>
        /// <param name="lh">the source scalar</param>
        /// <param name="rh">the source vector</param>
        /// <returns>the or'd vector</returns>
        public static <#= GetName(Dimension, false) #><T> operator |(T lh, <#= GetName(Dimension, false) #><T> rh) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh | rh.<#=GetComponentName(i)#><#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);
        /// <summary>
        /// XOR the components of the source vector with the source scalar
        /// </summary>
        /// <param name="lh">the source scalar</param>
        /// <param name="rh">the source vector</param>
        /// <returns>the xor'd vector</returns>
        public static <#= GetName(Dimension, false) #><T> operator ^(T lh, <#= GetName(Dimension, false) #><T> rh) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>lh ^ rh.<#=GetComponentName(i)#><#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);

        /// <summary>
        /// Not the components of the given vector
        /// </summary>
        /// <param name="val">the source vector</param>
        /// <returns>The not'd vector</returns>
        public static <#= GetName(Dimension, false) #><T> operator ~(<#= GetName(Dimension, false) #><T> val) => new(<#
                            for (int i = 0; i < Dimension; i++)
                            {#>~val.<#=GetComponentName(i)#><#= i < Dimension - 1 ? ", " : "" #><#
                            }#>);

        #endregion
<#
    }#>
    }
}
<#+
        public string GetName(int dimension, bool floatType)
        {
            return "Vector" + dimension + (floatType ? "F" : "I");
        }

        private string GetComponentName(int dimension, bool Caps = true)
        {
            switch (dimension)
            {
                default:
                case 0:
                    return Caps ? "X" : "x";
                case 1:
                    return Caps ? "Y" : "y";
                case 2:
                    return Caps ? "Z" : "z";
                case 3:
                    return Caps ? "W" : "w";
                case 4:
                    return Caps ? "V" : "v";
                case 5:
                    return Caps ? "U" : "u";
            }
        }

        public string GetSwizzleName(int[] components, string separator)
        {
            string st = "";
            for (int i = 0; i < components.Length; i++)
            {
                st += GetComponentName(components[i]) + ((i < components.Length - 1) ? separator : "");
            }
            return st;
        }

        private string ForEachComponent(int dimensions, string prefix, string separator, string postfix, bool Caps = true, int start = 0)
        {
            string st = prefix;
            for (int i = start; i < dimensions; i++)
            {
                st += GetComponentName(i, Caps);

                if (i < dimensions - 1)
                {
                    st += separator;
                }
            }
            st += postfix;
        
        return st;
        }

        private string ForEachComponent(int dimensions, string prefix, string val, string separator, string postfix, int start = 0)
        {
            string st = prefix;
            for (int i = 0; i < dimensions; i++)
            {
                st += val;

                if (i < dimensions - 1)
                {
                    st += separator;
                }
            }
            st += postfix;
        
        return st;
        }

        private bool IsPowerOfTwo(int i)
        {
            return (i != 0) && ((i & (i - 1)) == 0);
        }

        private string GetMatrixMultiplication(int matrixRows, int matrixCols, int dimension, bool floatType, string vectorName, string matrixName, bool homogenous)
        {
            string ret;
            string components;
            if (matrixRows < dimension)
            {
                components = "";
                for (int i = 0; i < matrixRows; i++)
                    components += GetComponentName(i);
                ret = "(" + vectorName + ".Swizzle." + components + " * " + matrixName + ")";
            }
            else if (matrixRows == dimension)
            {
                ret = "(" + vectorName + " * " + matrixName + ")";
            }
            else
            {
                ret = "(new Vector" + dimension + (floatType ? "F" : "I") + "<T>(";
                for (int i = 0; i < dimension; i++)
                    ret += vectorName + "." + GetComponentName(i) + (i < dimension - 1 ? ", " : ") * ");
                ret += matrixName + ")";
            }

            if (matrixCols > dimension)
            {
                components = "";
                for (int i = 0; i < dimension; i++)
                    components += GetComponentName(i);
                ret += "Swizzle." + components;
            }
            else if (matrixCols < dimension)
            {
                int diff = dimension - matrixCols;
                components = "";
                for (int i = 0; i < diff; i++)
                    components += (i < diff - 2 || !homogenous ? "T.Zero" : "T.One") + (i < diff - 1 ? ", " : ")");
                ret = "new Vector" + dimension + (floatType ? "F" : "I") + "<T>(" + ret + components;
            }

            return ret + ";";
}#>